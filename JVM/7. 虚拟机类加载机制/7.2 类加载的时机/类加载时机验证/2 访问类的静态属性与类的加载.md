# 访问类的静态属性与类的初始化
---

## 验证

现有SuperClass类，其源码如下：

```java
public class SuperClass {
    public static String staticVariable = "hello ";
    public static final String STATIC_CONSTANT = "world!";

    static {
        System.out.println("SuperClass is loading.");
    }
}
```

现有两段代码，分别引用SuperClass类中的静态属性和静态常量：

```java
public class MainClass {
    static {
        System.out.println("MainClass is loading.");
    }

    public static void main(String[] args) {
        System.out.println(SuperClass.staticVariable);//静态属性
    }
}
```

```java
public class MainClass {
    static {
        System.out.println("MainClass is loading.");
    }

    public static void main(String[] args) {
        System.out.println(SuperClass.STATIC_CONSTANT);//静态常量
    }
}
```

上述两段代码的执行结果分别如下：

（引用静态属性）

```
MainClass is loading.
SuperClass is loading.
hello 
```

(引用静态常量)

```
MainClass is loading.
world!
```

对比两段代码的运行结果，可以看到对静态常量的引用并没有触发常量所在类的初始化。

## 分析

虽然在Java源码中引用了SuperClass类的常量STATIC_CONSTANT，但是其实在编译阶段通过<font color = orange>**常量传播优化**</font>，此常量的值"world!"已经被存储到了MainClass类的常量池中，之后MainClass对SuperClass.STATIC_CONSTANT的引用，实际都被转化为MainClass对自身常量池的引用了。也就是说，MainClass类的Class文件中，并没有SuperClass类的符号引用入口，MainClass类与SuperClass类在编译成Class文件以后就不存在任何联系了。

---

《深入理解Java虚拟机》学习笔记