# 数据库的4种隔离等级

---

### 第1级别：Read Uncommitted（读取未提交内容）

1. 所有事务都可以看到其他未提交事务的执行结果。读取未提交的数据，也被称之为脏读（Dirty Read）
2. 本隔离等级很少用于实际应用，因为它的性能并不比其他级别好多少。
3. 本级别存在的问题——读脏数据：读取到了其他事务未提交的数据

### 第2级别：Read Committed（读取已提交内容）

1. 这是大多数数据库默认的隔离等级（但不是MySQL默认的）

2. 它满足了隔离的简单定义：一个事务只能看见已提交事务所作的改变。

3. 本级别存在的问题——不可重复读：不可重复读意味着我们在同一个事务中执行完全相同的select语句，可能得到不用的结果。导致的原因可能有

    ① 有一个交叉事务有了新的commit，导致数据的改变；

    ② 一个数据库被多个实例操作时,同一事务的其他实例在该实例处理其间可能会有新的commit

### 第3级别：Repeatable Read（可重复读）

1. <font color = red>这是MySQL默认的隔离级别</font>
2. 它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行
3. 本级别存在的问题——幻读(Phantom Read)：当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行
4. InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了该问题

### 第4级别：Serializable（可串行化）

1. 最高的隔离等级
2. 通过强制事务排序，使之不可能产生冲突，从而解决幻读问题。简而言之，就是在每个读的数据行上添加共享锁。
3. 本级别存在的问题——可能导致大量的超时现象以及锁竞争